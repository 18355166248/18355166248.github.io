(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{457:function(n,t,e){"use strict";e.r(t);var s=e(45),l=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_31-下一个排列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_31-下一个排列"}},[n._v("#")]),n._v(" 31. 下一个排列")]),n._v(" "),e("p",[n._v("// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n// 必须 原地 修改，只允许使用额外常数空间。\nvar nextPermutation = function(nums) {\n// 倒序, 算出第一个前面数字大于后面数组的索引\nlet i = nums.length - 2;")]),n._v(" "),e("p",[n._v("// 找到第一个小于右侧数字的索引\nwhile (i >= 0 && nums[i] >= nums[i + 1]) {\ni--;\n}")]),n._v(" "),e("p",[n._v("// 这个数在数组中存在, 从最后往前找到第一个比i大的数字\nif (i >= 0) {\nlet j = nums.length - 1;")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("while (j >= 0 && nums[j] <= nums[i]) {\n  j--;\n}\n// 这几个数百分百存在的 所以直接交换就行了\n[nums[i], nums[j]] = [nums[j], nums[i]];\n")])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("// 假如说这个数为-1, 那么就直接翻转数组\n// 如果这个数不是-1, 就对i右侧的数据排序, 取最小值, 这样的话最后的数组就是最小的值\nlet l = i + 1;\nlet r = nums.length - 1;\nwhile (l < r) {\nif (nums[l] > nums[r]) {\n[nums[l], nums[r]] = [nums[r], nums[l]];\n}\nl++;\nr--;\n}")]),n._v(" "),e("p",[n._v("return nums;\n};")]),n._v(" "),e("p",[n._v("console.log(nextPermutation([1, 2, 3]));\nconsole.log(nextPermutation([3, 2, 1]));\nconsole.log(nextPermutation([1, 1, 5]));\nconsole.log(nextPermutation([1]));\nconsole.log(nextPermutation([1, 3, 2]));\nconsole.log(nextPermutation([5, 4, 7, 5, 3, 2]));")])])}),[],!1,null,null,null);t.default=l.exports}}]);