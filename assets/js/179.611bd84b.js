(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{564:function(n,t,r){"use strict";r.r(t);var e=r(45),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"打家劫舍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#打家劫舍"}},[n._v("#")]),n._v(" 打家劫舍")]),n._v(" "),r("p",[n._v("function solution(arr) {\nconst length = arr.length;\nif (length === 0) return 0;\nif (length === 1) return arr[0];")]),n._v(" "),r("p",[n._v("const dp = Array.from({ length: length + 1 }, () => [0, 0]);")]),n._v(" "),r("p",[n._v("// 动态规划, 当前房间要么偷, 要么不偷 我们只考虑当前值和之前的值, 之后的不考虑\n// 如果偷的话 只有一种情况 左边的就不能偷\n// 如果不偷的话 有2种情况 左边的偷或者左边的不偷\n// 我们规定不偷为0的话, 偷就为1 我们数组长度为n, 所以我们就有n长度的数组, 每个索引下有2种情况, 一种为0的情况, 一种为1的情况")]),n._v(" "),r("p",[n._v("for (let i = 1; i <= length; i++) {\ndp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\ndp[i][1] = dp[i - 1][0] + arr[i - 1];\n}")]),n._v(" "),r("p",[n._v("return Math.max(dp[length][0], dp[length][1]);\n}")]),n._v(" "),r("p",[n._v("const a = [2, 7, 9, 3, 1];")]),n._v(" "),r("p",[n._v("console.log(solution(a));")])])}),[],!1,null,null,null);t.default=a.exports}}]);