(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{488:function(n,t,e){"use strict";e.r(t);var o=e(45),r=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_73-矩阵置零"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_73-矩阵置零"}},[n._v("#")]),n._v(" 73. 矩阵置零")]),n._v(" "),e("p",[n._v("// 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。\n// 进阶：\n// 一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n// 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n// 你能想出一个仅使用常量空间的解决方案吗？\nvar setZeroes = function(matrix) {\nconst m = matrix.length,\nn = matrix[0].length;\nconst row = Array(m).fill(false);\nconst column = Array(n).fill(false);")]),n._v(" "),e("p",[n._v("for (let i = 0; i < m; i++) {\nfor (let j = 0; j < n; j++) {\nif (matrix[i][j] === 0) row[i] = column[j] = true;\n}\n}\nfor (let i = 0; i < m; i++) {\nfor (let j = 0; j < n; j++) {\nif (row[i] || column[j]) matrix[i][j] = 0;\n}\n}")]),n._v(" "),e("p",[n._v("console.log(matrix)\n};\nconsole.log(\nsetZeroes([\n[1, 1, 1],\n[1, 0, 1],\n[1, 1, 1],\n])\n); // [[1,0,1],[0,0,0],[1,0,1]]\nconsole.log(\nsetZeroes([\n[0, 1, 2, 0],\n[3, 4, 5, 2],\n[1, 3, 1, 5],\n])\n); // [[0,0,0,0],[0,4,5,0],[0,3,1,0]]")])])}),[],!1,null,null,null);t.default=r.exports}}]);