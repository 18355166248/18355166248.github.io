(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{581:function(n,l,t){"use strict";t.r(l);var i=t(45),u=Object(i.a)({},(function(){var n=this,l=n.$createElement,t=n._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"非递归快排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非递归快排"}},[n._v("#")]),n._v(" 非递归快排")]),n._v(" "),t("p",[n._v("function quickSort(num) {\n_quickSort(num, 0, num.length - 1); // 将整个num数组快速排序，left和right分别指向数组左右两端。")]),n._v(" "),t("p",[n._v("// console.log(num);\n}")]),n._v(" "),t("p",[n._v("function _quickSort(num, left, right) {\nvar list = [[left, right]]; // 将[left,right]存入数组中，类似于递归入栈\nwhile (list.length > 0) {\n// 若list不为空，循环弹出list最后一个数组进行快排\nvar now = list.pop(); // 弹出list末尾。(也可用list.shift()取出list第一个数组，但在数据量较大时，这种方式效率较低)\nif (now[0] >= now[1]) {\n// 若左右指针相遇，待排序数组长度小宇1，则无需进行快排(注意不能写成now[0]==now[1]，这里now[0]是有可能大于now[1]的\ncontinue;\n}\nvar i = now[0],\nj = now[1],\nflag = now[0]; // 以下与递归方法相同，请参考上面的递归详解\nwhile (i < j) {\nwhile (num[j] >= num[flag] && j > flag) j--; // j不断左移，找到在num[flag]右侧且比它大的数。\nif (i >= j) {\nbreak; // 由于j可能已被改变，需再次判断i与j是否碰头。\n}\nwhile (num[i] <= num[flag] && i < j) i++; // i不断右移，找到且比基数小的数，且i不能与j碰头。(由于两次交换已合并，此处不需要使得i在flag左侧)\n// num[flag] num[j] num[i]三者换位，可用ES6语法糖[num[flag],num[j],num[i]] = [num[j],num[i],num[flag]];\nconsole.log(i, j, flag);\nlet temp = num[flag];\nnum[flag] = num[j];\nnum[j] = num[i];\nnum[i] = temp;\nflag = i; // 基数已经在原num[i]的位置，flag同时也要赋值成i\nconsole.log(num);\n}\nlist.push([now[0], flag - 1]); // 将flag左边数组作为待排序数组，只需将左右指针放入list即可。\nlist.push([flag + 1, now[1]]); // 将flag右边数组作为待排序数组，只需将左右指针放入list即可。\n}\n}")]),n._v(" "),t("p",[n._v("console.log(quickSort([9, 17, 0, 6, 10, 5]));")])])}),[],!1,null,null,null);l.default=u.exports}}]);