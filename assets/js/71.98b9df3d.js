(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{455:function(s,n,o){"use strict";o.r(n);var r=o(45),t=Object(r.a)({},(function(){var s=this,n=s.$createElement,o=s._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[o("h1",{attrs:{id:"_30-串联所有单词的子串"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_30-串联所有单词的子串"}},[s._v("#")]),s._v(" 30. 串联所有单词的子串")]),s._v(" "),o("p",[s._v("// 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。")]),s._v(" "),o("p",[s._v("// 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。")]),s._v(" "),o("p",[s._v("var findSubstring = function(s, words) {\nconst len = words[0].length\nconst res = []\n// 循环, 循环的次数为字符串长度减去words所有字符串总和长度-1, 因为这个长度后面的字符串肯定不能拼接成words数组的数据\nfor (let i = 0; i <= s.length - words.length * len; i++) {\nconst wordsCopy = [...words]\n// 深度优先遍历\ndfs(wordsCopy, s.substring(i), i)\n}")]),s._v(" "),o("p",[s._v("return res")]),s._v(" "),o("p",[s._v("function dfs(arr, s, start) {\n// 递归的结束条件为数组的长度为0, 或者进不去下方的判断\nif (arr.length === 0) return res.push(start)")]),s._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[s._v("// 从字符串开始剪切固定长度字符串, 去words中查找, 如果找不到, 结束, 如果找到了 继续往下查找\nconst str = s.substr(0, len)\n\nconst index = arr.findIndex((item) => item === str)\n\nif (index > -1) {\n  // 递归查找之前需要将已经使用过的数组索引删除, 字符串也需要删除已经判断过的\n  arr.splice(index, 1)\n  dfs(arr, s.substring(len), start)\n}\n")])])]),o("p",[s._v("}\n}")]),s._v(" "),o("p",[s._v("const s = 'barfoothefoobarman',\nwords = ['foo', 'bar']")]),s._v(" "),o("p",[s._v("const s1 = 'wordgoodgoodgoodbestword',\nwords1 = ['word', 'good', 'best', 'word']")]),s._v(" "),o("p",[s._v("const s2 = 'wordgoodgoodgoodbestword',\nwords2 = ['word', 'good', 'best']")]),s._v(" "),o("p",[s._v("console.log(findSubstring(s, words))\nconsole.log(findSubstring(s1, words1))\nconsole.log(findSubstring(s2, words2))")])])}),[],!1,null,null,null);n.default=t.exports}}]);