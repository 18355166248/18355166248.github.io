(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{441:function(n,t,e){"use strict";e.r(t);var s=e(45),r=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_15-三数之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-三数之和"}},[n._v("#")]),n._v(" 15. 三数之和")]),n._v(" "),e("p",[n._v("// 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。")]),n._v(" "),e("p",[n._v("// 注意：答案中不可以包含重复的三元组。\nvar threeSum = function(nums) {\nif (nums.length < 3) return [];")]),n._v(" "),e("p",[n._v("// 排序\nnums = nums.sort((a, b) => a - b);")]),n._v(" "),e("p",[n._v("const arr = [];")]),n._v(" "),e("p",[n._v("for (let i = 0; i < nums.length - 2; i++) {\nconst n1 = nums[i];\nif (n1 > 0) break; // 如果第一个大于0, 表示后面的和肯定不会等于0, 直接停止\nif (i - 1 >= 0 && nums[i - 1] === n1) continue;")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("// 第一层循环内, 使用左右指针的概念进行遍历查找, 其实就是多指针+\nlet left = i + 1;\nlet right = nums.length - 1;\n\nwhile (left < right) {\n  const n2 = nums[left],\n    n3 = nums[right];\n\n  // 先判断三指针和是否为0 ,如果是就左右指针往里排重收缩\n  // 如果三指针合不为0, 再判断是否小于0. 如果小于0, 表示值小了 左指针前进\n  // 反之右指针后退\n  if (n1 + n2 + n3 === 0) {\n    arr.push([n1, n2, n3]);\n\n    // 在拿到3数之和为0之后, 需要判断是否有重复数, 如果有, 就指针往里收缩, 知道没有相等的树\n    while (left < right && nums[left] === n2) left++;\n    while (left < right && nums[right] === n3) right++;\n  } else if (n1 + n2 + n3 < 0) {\n    // 和小于0 那么左指针前进\n    left++;\n  } else {\n    // 和大于0 右指针后退\n    right--;\n  }\n}\n")])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("return arr;\n};")]),n._v(" "),e("p",[n._v("const nums = [-1, 0, 1, 2, -1, -4];\nconst nums2 = [0, 0, 0, 0];")]),n._v(" "),e("p",[n._v("console.log(threeSum(nums));\nconsole.log(threeSum(nums2));")])])}),[],!1,null,null,null);t.default=r.exports}}]);