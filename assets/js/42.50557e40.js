(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{429:function(n,t,e){"use strict";e.r(t);var l=e(45),a=Object(l.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_113-路径总和-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_113-路径总和-ii"}},[n._v("#")]),n._v(" 113. 路径总和 II")]),n._v(" "),e("p",[n._v("// 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n// 叶子节点 是指没有子节点的节点。\nvar pathSum = function(root, targetSum) {\nif (!root) return [];\nlet resArr = [];")]),n._v(" "),e("p",[n._v("dfs(root, 0, []);")]),n._v(" "),e("p",[n._v("function dfs(node, num, res) {\nif (!node.left && !node.right) {\nif (num + node.val === targetSum) resArr.push([...res, node.val]);\nreturn;\n}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("if (\n  (targetSum >= 0 && num + node.val > targetSum) ||\n  (targetSum < 0 && num + node.val < targetSum)\n)\n  return;\n\nnode.left && dfs(node.left, num + node.val, [...res, node.val]);\nnode.right && dfs(node.right, num + node.val, [...res, node.val]);\n")])])]),e("p",[n._v("}")]),n._v(" "),e("p",[n._v("return resArr;\n};")]),n._v(" "),e("p",[n._v("console.log(\npathSum(\n{\nval: 5,\nleft: {\nval: 4,\nleft: {\nval: 11,\nleft: {\nval: 7,\n},\nright: {\nval: 2,\n},\n},\n},\nright: {\nval: 8,\nleft: {\nval: 13,\n},\nright: {\nval: 4,\nleft: {\nval: 5,\n},\nright: {\nval: 1,\n},\n},\n},\n},\n22\n)\n);\nconsole.log(\npathSum(\n{\nval: 1,\nleft: {\nval: 2,\n},\nright: {\nval: 3,\n},\n},\n5\n)\n);\nconsole.log(\npathSum(\n{\nval: 1,\nleft: {\nval: 2,\n},\n},\n0\n)\n);\nconsole.log(pathSum(null, 0));\nconsole.log(\npathSum(\n{\nval: -2,\nright: {\nval: -3,\n},\n},\n-5\n)\n);")])])}),[],!1,null,null,null);t.default=a.exports}}]);