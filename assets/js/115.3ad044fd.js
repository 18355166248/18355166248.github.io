(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{501:function(n,e,t){"use strict";t.r(e);var l=t(45),a=Object(l.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_86-分隔链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_86-分隔链表"}},[n._v("#")]),n._v(" 86. 分隔链表")]),n._v(" "),t("p",[n._v("// 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。\n// 你应当 保留 两个分区中每个节点的初始相对位置。\nfunction ListNode(val, next) {\nthis.val = val === undefined ? 0 : val\nthis.next = next === undefined ? null : next\n}\nvar partition = function(head, x) {\nlet small = new ListNode()\nconst smallHead = small\nlet large = new ListNode()\nconst largeHead = large")]),n._v(" "),t("p",[n._v("while (head) {\nif (head.val < x) {\nsmall.next = head\nsmall = small.next\n} else {\nlarge.next = head\nlarge = large.next\n}\nhead = head.next\n}")]),n._v(" "),t("p",[n._v("large.next = null\nsmall.next = largeHead.next")]),n._v(" "),t("p",[n._v("return smallHead.next\n}\nconsole.log(\npartition(\n{\nval: 1,\nnext: {\nval: 4,\nnext: {\nval: 3,\nnext: {\nval: 2,\nnext: {\nval: 5,\nnext: {\nval: 2,\nnext: null,\n},\n},\n},\n},\n},\n},\n3\n)\n) // [1,2,2,4,3,5]")])])}),[],!1,null,null,null);e.default=a.exports}}]);