(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{417:function(n,e,r){"use strict";r.r(e);var t=r(45),o=Object(t.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"_106-从中序与后序遍历序列构造二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_106-从中序与后序遍历序列构造二叉树"}},[n._v("#")]),n._v(" 106. 从中序与后序遍历序列构造二叉树")]),n._v(" "),r("p",[n._v("// 根据一棵树的中序遍历与后序遍历构造二叉树。\n// 注意:\n// 你可以假设树中没有重复的元素。\n// 例如，给出\n// 中序遍历 inorder = [9,3,15,20,7]\n// 后序遍历 postorder = [9,15,7,20,3]\n// 返回如下的二叉树：\n//     3\n//    / "),r("br"),n._v("\n//   9  20\n//     /  "),r("br"),n._v("\n//    15   7\n// ```js\n// // 后序遍历的数组最后一个元素代表的即为根节点")]),n._v(" "),r("p",[n._v("// // 中序遍历的顺序是每次遍历左孩子，再遍历根节点，最后遍历右孩子。\n// // 后序遍历的顺序是每次遍历左孩子，再遍历右孩子，最后遍历根节点。\n// void inorder(TreeNode* root) {\n//   if (root == nullptr) {\n//       return;\n//   }\n//   inorder(root->left);\n//   ans.push_back(root->val);\n//   inorder(root->right);\n// }\n// // 后序遍历\n// void postorder(TreeNode* root) {\n//   if (root == nullptr) {\n//       return;\n//   }\n//   postorder(root->left);\n//   postorder(root->right);\n//   ans.push_back(root->val);\n// }\n// ```;\nfunction TreeNode(val, left, right) {\nthis.val = val === undefined ? 0 : val;\nthis.left = left === undefined ? null : left;\nthis.right = right === undefined ? null : right;\n}\nvar buildTree = function(inorder, postorder) {\nlet posIndex; // 表示后序遍历最后的index 后序遍历的数组最后一个元素代表的即为根节点")]),n._v(" "),r("p",[n._v("const map = new Map(); // 缓存中序遍历的哈希表, 用于通过后序遍历的val找到对应在中序遍历的索引")]),n._v(" "),r("p",[n._v("inorder.forEach((val, index) => {\nmap.set(val, index);\n});")]),n._v(" "),r("p",[n._v("function deep(in_left, in_right) {\nif (in_left > in_right) return null; // 表示没有节点可以构造了")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[n._v("const root_val = postorder[posIndex];\nconst in_index = map.get(root_val); // 后序遍历最后的值在中序遍历中所在的索引, 也是表示根节点\nconst root = new TreeNode(root_val); // 生成根节点\n\nposIndex--; // 更新 后序遍历最后的索引\n\nroot.right = deep(in_index + 1, in_right); // 生成右子树\nroot.left = deep(in_left, in_index - 1); // 生成左子树\n\nreturn root;\n")])])]),r("p",[n._v("}")]),n._v(" "),r("p",[n._v("posIndex = postorder.length - 1;")]),n._v(" "),r("p",[n._v("return deep(0, inorder.length - 1);\n};")]),n._v(" "),r("p",[n._v("console.log(buildTree([9, 3, 15, 20, 7], [9, 15, 7, 20, 3]));")])])}),[],!1,null,null,null);e.default=o.exports}}]);