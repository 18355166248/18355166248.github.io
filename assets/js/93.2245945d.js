(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{478:function(n,t,e){"use strict";e.r(t);var r=e(45),l=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_57-插入区间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_57-插入区间"}},[n._v("#")]),n._v(" 57. 插入区间")]),n._v(" "),e("p",[n._v("// 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。\n// 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。\nvar insert = function(intervals, newInterval) {\nif (intervals.length === 0) return [newInterval];\nconst arr = [];\nlet [left, right] = newInterval;\nlet placed = false;\nfor (let i = 0; i < intervals.length; i++) {\nconst cur = intervals[i];\n// 当前数组左侧大于插入数组的最大值, 插入数组在当前数组的左侧\nif (cur[0] > right) {\nif (!placed) {\narr.push([left, right]);\nplaced = true;\n}")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("  arr.push(cur);\n} else if (cur[1] < left) {\n  // 当前数组最大值小于插入数组最小值, 插入数组在右侧, 不用管\n  arr.push(cur);\n} else {\n  // 有交集\n  left = Math.min(left, cur[0]);\n  right = Math.max(right, cur[1]);\n}\n")])])]),e("p",[n._v("}\nif (!placed) arr.push([left, right]);\nreturn arr;\n};\nconsole.log(\ninsert(\n[\n[1, 3],\n[6, 9],\n],\n[2, 5]\n)\n); // [[1,5],[6,9]]\nconsole.log(\ninsert(\n[\n[1, 2],\n[3, 5],\n[6, 7],\n[8, 10],\n[12, 16],\n],\n[4, 8]\n)\n); // [[1,2],[3,10],[12,16]]")])])}),[],!1,null,null,null);t.default=l.exports}}]);