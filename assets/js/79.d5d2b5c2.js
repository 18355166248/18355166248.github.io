(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{466:function(t,n,a){"use strict";a.r(n);var e=a(45),i=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_40-组合总和-ii"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_40-组合总和-ii"}},[t._v("#")]),t._v(" 40. 组合总和 II")]),t._v(" "),a("p",[t._v("// 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n// candidates 中的每个数字在每个组合中只能使用一次。\n// 说明：\n// 所有数字（包括目标数）都是正整数。\n// 解集不能包含重复的组合。\nvar combinationSum2 = function(candidates, target) {\nif (candidates.length === 0) return [];\ncandidates = candidates.sort((a, b) => a - b);\nconst totalArr = [];")]),t._v(" "),a("p",[t._v("function dfs(arr, res, start) {\nfor (let i = start; i < candidates.length; i++) {\nconst item = candidates[i];\nif (i - 1 >= start && item === candidates[i - 1]) continue;\nconst sum = res + item;\nif (sum === target) {\ntotalArr.push([...arr, item]);\nbreak;\n} else if (sum > target) {\ncontinue;\n} else {\ndfs([...arr, item], sum, i + 1);\n}\n}\n}")]),t._v(" "),a("p",[t._v("dfs([], 0, 0);")]),t._v(" "),a("p",[t._v("return totalArr;\n};")]),t._v(" "),a("p",[t._v("console.log(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8));\nconsole.log(combinationSum2([2, 5, 2, 1, 2], 5));")])])}),[],!1,null,null,null);n.default=i.exports}}]);