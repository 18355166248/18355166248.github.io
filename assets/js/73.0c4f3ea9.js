(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{458:function(n,t,e){"use strict";e.r(t);var s=e(45),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_32-最长有效括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_32-最长有效括号"}},[n._v("#")]),n._v(" 32. 最长有效括号")]),n._v(" "),e("p",[n._v("// 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度"),e("br"),n._v("\n// 栈的方式\nvar longestValidParentheses = function(s) {\nconst stack = [-1];\nlet maxLength = 0;")]),n._v(" "),e("p",[n._v('for (let i = 0; i < s.length; i++) {\nif (s[i] === ")") {\nstack.pop();\n// 栈为空计算最大值\nif (stack.length) {\n// 清除栈后, 计算最大值\nconst max = i - stack[stack.length - 1];\nmaxLength = Math.max(max, maxLength);\n} else {\n// 栈空了, 入参充当参照\nstack.push(i);\n}\n} else {\nstack.push(i);\n}\n}\nreturn maxLength;\n};')]),n._v(" "),e("p",[n._v('console.log(longestValidParentheses("(()")); // 2\nconsole.log(longestValidParentheses(")()())")); // 4\nconsole.log(longestValidParentheses("()")); // 2')])])}),[],!1,null,null,null);t.default=a.exports}}]);