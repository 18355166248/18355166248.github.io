(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{486:function(t,n,a){"use strict";a.r(n);var s=a(45),i=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_71-简化路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_71-简化路径"}},[t._v("#")]),t._v(" 71. 简化路径")]),t._v(" "),a("p",[t._v("// 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。")]),t._v(" "),a("p",[t._v("// 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。")]),t._v(" "),a("p",[t._v("// 请注意，返回的 规范路径 必须遵循下述格式：")]),t._v(" "),a("p",[t._v("// 始终以斜杠 '/' 开头。\n// 两个目录名之间必须只有一个斜杠 '/' 。\n// 最后一个目录名（如果存在）不能 以 '/' 结尾。\n// 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。\n// 返回简化后得到的 规范路径 。\nvar simplifyPath = function(path) {\nconst stack = [];\npath = path.split(\"/\");\nfor (let i = 0; i < path.length; i++) {\nif (path[i] === \"..\" && stack.length) {\nstack.pop();\n} else if (path[i] !== \".\" && path[i] !== \"\" && path[i] !== \"..\") {\nstack.push(path[i]);\n}\n}")]),t._v(" "),a("p",[t._v('return "/" + stack.join("/");\n};\nconsole.log(simplifyPath("/home/"));\nconsole.log(simplifyPath("/../"));')])])}),[],!1,null,null,null);n.default=i.exports}}]);