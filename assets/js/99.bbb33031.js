(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{483:function(n,t,e){"use strict";e.r(t);var s=e(45),i=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_63-不同路径-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_63-不同路径-ii"}},[n._v("#")]),n._v(" 63. 不同路径 II")]),n._v(" "),e("p",[n._v("// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n// 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\nvar uniquePathsWithObstacles = function(obstacleGrid) {\nconst end1 = obstacleGrid.length,\nend2 = obstacleGrid[0].length;")]),n._v(" "),e("p",[n._v("const dp = Array.from({ length: end1 }, (_) => Array(end2).fill(0));")]),n._v(" "),e("p",[n._v("for (let i = 0; i < end1 && obstacleGrid[i][0] === 0; i++) {\ndp[i][0] = 1;\n}\nfor (let j = 0; j < end2 && obstacleGrid[0][j] === 0; j++) {\ndp[0][j] = 1;\n}")]),n._v(" "),e("p",[n._v("for (let i = 1; i < end1; i++) {\nfor (let j = 1; j < end2; j++) {\nif (obstacleGrid[i][j] === 0) {\ndp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n}\n}\n}")]),n._v(" "),e("p",[n._v("return dp[end1 - 1][end2 - 1];\n};\nconsole.log(\nuniquePathsWithObstacles([\n[0, 0, 0],\n[0, 1, 0],\n[0, 0, 0],\n])\n); // 2\n// console.log(\n//   uniquePathsWithObstacles([\n//     [0, 1],\n//     [0, 0],\n//   ])\n// ); // 1\n// console.log(\n//   uniquePathsWithObstacles([\n//     [0, 0],\n//     [0, 1],\n//   ])\n// ); // 0\n// console.log(uniquePathsWithObstacles([[0, 1]])); // 0\n// console.log(uniquePathsWithObstacles([[1, 0]])); // 0\n// console.log(\n//   uniquePathsWithObstacles([\n//     [0, 1, 0, 0, 0],\n//     [1, 0, 0, 0, 0],\n//     [0, 0, 0, 0, 0],\n//     [0, 0, 0, 0, 0],\n//   ])\n// ); // 0")])])}),[],!1,null,null,null);t.default=i.exports}}]);